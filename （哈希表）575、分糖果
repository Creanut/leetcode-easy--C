/*
给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。

示例 1:

输入: candies = [1,1,2,2,3,3]
输出: 3
解析: 一共有三种种类的糖果，每一种都有两个。
     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。
示例 2 :

输入: candies = [1,1,2,3]
输出: 2
解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。
注意:

数组的长度为[2, 10,000]，并且确定为偶数。
数组中数字的大小在范围[-100,000, 100,000]内。
*/

int distributeCandies(int* candies, int candiesSize)
{
    int* kind_hash = (int*)calloc(200001, sizeof(int));
    for(int i = 0; i < candiesSize; i++)
    {
        kind_hash[candies[i]+100000]++;
    }
    
    int kinds = 0;
    for(int i = 0; i < 200001; i++)
    {
        if(kind_hash[i] != 0)
            kinds++;
    }
    
    return (kinds < candiesSize / 2) ? kinds : candiesSize / 2;
}

/*
最大极端情况，所有糖都不重样，那妹妹也只能得到一半。 
中间情况，每个糖都有两个，那妹妹刚好能得到所有种类，数量跟第一种一样。 
最小极端情况，就一种糖，那妹妹就只能得到一种。

思想：不管有多少种，先每种一个给妹妹，如果才给了妹妹几个，所有的种类就都给过了，那后面的都是重复的了。
如果给了妹妹一半的数量，还有不重样的，那妹妹最多也就只有一半数量的种类。
所以说到最后，看（数量的一半）和（所有的种类）哪个先达到，也就是取两者中较小的值。

所以问题就转化成了如何统计糖果的种类。由于题目说明数组中的数字大小的取值范围是[-100000,100000]，
所以糖果的种类最大就是200001种，因此只需要构建一个长度为200001的哈希表，先遍历赋值，再遍历统计即可得到糖果的种类数。
*/
